//树向二叉树的转换
/*
       A
     / | \
    /  |  \
   B - C - D
  /    |
 /     |
E  -   F

       A
     /  
    /    
   B - C - D
  /   
 /     
E  -   F
水平链顺时针旋转45度,成为二叉树
    A
   /
  B
 / \
E   C
 \   \
 F    D
 二叉树转为树逆向旋转即可
 森林转变为二叉树
 将几个森林的根节点水平连起来，每个森林的链接只保留孩子兄弟链接
 顺时针旋转即可以将森林转变为二叉树
 二叉树变为森林标记几个根部节点，逆向旋转即可
*/
/*
前序遍历一棵树恰好等于前序遍历该树对应的二叉树
后续遍历一颗树恰好等于中序遍历该树对应的二叉树
*/
//哈夫曼树（最优二叉树）--哈夫曼编码（最优前缀编码）
/*
特点：带权路径长度最短
树的路径长度是从树根到每一个叶子之间的路径长度之和
节点的带权路径长度为树根到该节点的路径长度*节点权（特定权重，比如字符串中字符出现的频率）
树的带权路径长度（树的代价）=所有节点的带权路径长度之和
*/
//贪婪算法：在对问题求解时总是做出在当时来看最好的选择，也就是说不从整体上加以考虑，做出局部的最优解
//构建哈夫曼树：
/*哈夫曼树的数据全都在叶子节点，不看根和中间节点
1.从一堆数列中每次选出权值最小的两个树，构成左右子树（小值在左） 
2.得到左右相加的值作为父节点的值，这样构成了一个二叉树，然后把父节点的值返回数列中形成新的数列
3.再从数列中选出最小的两个值（这时候1步骤的父节点成为了子节点之一），继续重复1过程直到数列中的树取完
例如：01234 
a.     b.      c.                d.
 1       3         6                10
0  1   1   2     3   3            4    6
      0  1     1   2                 3   3
	         0   1                 1   2
			                     0   1
*/
/*
前缀编码 在一个字符集中任何一个字符都不是另一个字符的前缀 如01 是010的前缀  001不是100的前缀
哈夫曼编码：对一个哈夫曼树的左边节点标记0，右边节点标记1，然后从根节点开始数到叶子节点的标记连起来就是这个叶子节点的编码
如：d里面4的编码为0，3的编码为11，2的编码为101，1的编码为1001
*/